### Day 07

[61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)

【思路——遍历链表】

将链表中每个节点向右移动k个位置，就相当于让链表中倒数第k个节点当新的头节点，把它前面的节点接到原链表结尾的后边。分为下面几步：

1. 先遍历链表，统计节点个数；
2. 找到**倒数第k个节点前面那个节点**，记为 `prev` ；
3. 从`prev`后面“断开”，`prev`的下一个节点为新的头节点，让`prev->next`指向空；再让原链表的尾节点的next指向原头节点。

【C++代码】

```c++
ListNode* rotateRight(ListNode* head, int k) {
    if(!head)  return head;
    
    ListNode* tmp = head;
    //统计原链表中节点的个数
    int cnt = 1;
    while(tmp->next){
        tmp = tmp->next;
        cnt ++;
    }  //tmp指向原链表的尾节点

    k %= cnt;
    if(k == 0)
        return head;
    
    int step = cnt - k - 1;
    ListNode* prev = head;
    while(step--){
        prev = prev->next;
    }

    ListNode* cur = prev->next;
    prev->next = nullptr;
    tmp->next = head;
    return cur;
}
```

时间复杂度： $O(N)$，两次遍历链表；

空间复杂度： $O(1)$
