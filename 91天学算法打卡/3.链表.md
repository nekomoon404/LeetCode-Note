### Day 07

[61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)

【思路——遍历链表】

将链表中每个节点向右移动k个位置，就相当于让链表中倒数第k个节点当新的头节点，把它前面的节点接到原链表结尾的后边。分为下面几步：

1. 先遍历链表，统计节点个数；
2. 找到**倒数第k个节点前面那个节点**，记为 `prev` ；
3. 从`prev`后面“断开”，`prev`的下一个节点为新的头节点，让`prev->next`指向空；再让原链表的尾节点的next指向原头节点。

【C++代码】

```c++
ListNode* rotateRight(ListNode* head, int k) {
    if(!head)  return head;
    
    ListNode* tmp = head;
    //统计原链表中节点的个数
    int cnt = 1;
    while(tmp->next){
        tmp = tmp->next;
        cnt ++;
    }  //tmp指向原链表的尾节点

    k %= cnt;
    if(k == 0)
        return head;
    
    int step = cnt - k - 1;
    ListNode* prev = head;
    while(step--){
        prev = prev->next;
    }

    ListNode* cur = prev->next;
    prev->next = nullptr;
    tmp->next = head;
    return cur;
}
```

时间复杂度： $O(N)$，两次遍历链表；

空间复杂度： $O(1)$

### Day 08

[24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

【思路——链表节点的next指针操作】

题目要求我们从头开始，两个一对交换链表中相邻的两个节点，记我们要交换的两个节点为 k1 和 k2；记k1前面一个节点为 prev，用题目中的例子即是`prev->k1->k2->3->4....`，要交换k1和k2需要三步操作：

```cpp
prev->next = k2;
k1->next = k2->next;
k2->next = k1;
```

交换后得到`prev->k2->k1->3->4....`，为交换后面的节点我们需要移动这三个指针，让prev指向k1，k1指向3，k2指向4，也是需要三步：

```cpp
prev = k1;
k1 = k1->next;
k2 = k1->next;
```

当然也要判断能不能向后走了，**交换完后**若要想后走就要保证后面的两个节点是存在的，即`k1->next && k1->next->next`为真。

为了方便处理边界条件，可以设一个虚拟头节点dummy，让dummy->next指向head；开始时让prev，k1和k2都指向dummy，发现执行一次上面的三步走法，刚好可以走成`prev->k1->k2->3->4...`；那我们只需要特判一下head是否为空就行了，其他情况都在while循环里了。

【C++代码】

```cpp
ListNode* swapPairs(ListNode* head) {
    if(!head)  return head;

    ListNode* dummy = new ListNode(-1);
    dummy->next = head;

    ListNode* prev = dummy;
    ListNode* k1 = dummy;
    ListNode* k2 = dummy;
    
    while(k1->next && k1->next->next){
        prev = k1;
        k1 = k1->next;
        k2 = k1->next;

        prev->next = k2;
        k1->next = k2->next;
        k2->next = k1;
    }

    return dummy->next;
}
```

时间复杂度： $O(N)$，遍历了一次链表；

空间复杂度： $O(1)$

### Day 09

[109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)

【思路——快慢指针找链表中点+递归】

每次用快慢指针找到链表的中点，作为根节点；处理左边的链作为左子树，处理右边的链作为右子树，这样递归下去。

【C++代码】

```c++
TreeNode* sortedListToBST(ListNode* head) {
    if(!head)  return nullptr;
    return toBST(head, nullptr);
}

TreeNode* toBST(ListNode* head, ListNode* tail){
    if(head == tail)  return nullptr;
    ListNode* fast = head;
    ListNode* slow = head;

    while(fast != tail && fast->next != tail){
        fast = fast->next->next;
        slow = slow->next;
    }

    TreeNode* root = new TreeNode(slow->val);
    root->left = toBST(head, slow);
    root->right = toBST(slow->next, tail);

    return root;
}
```

时间复杂度： $O(n \log n)$，找链表中点是$O(n)$，递归共$O(\log n)$层；

空间复杂度： $O(\log n)$，考虑递归调用栈的开销。