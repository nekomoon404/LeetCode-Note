### Day 07

[61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)

【思路——遍历链表】

将链表中每个节点向右移动k个位置，就相当于让链表中倒数第k个节点当新的头节点，把它前面的节点接到原链表结尾的后边。分为下面几步：

1. 先遍历链表，统计节点个数；
2. 找到**倒数第k个节点前面那个节点**，记为 `prev` ；
3. 从`prev`后面“断开”，`prev`的下一个节点为新的头节点，让`prev->next`指向空；再让原链表的尾节点的next指向原头节点。

【C++代码】

```c++
ListNode* rotateRight(ListNode* head, int k) {
    if(!head)  return head;
    
    ListNode* tmp = head;
    //统计原链表中节点的个数
    int cnt = 1;
    while(tmp->next){
        tmp = tmp->next;
        cnt ++;
    }  //tmp指向原链表的尾节点

    k %= cnt;
    if(k == 0)
        return head;
    
    int step = cnt - k - 1;
    ListNode* prev = head;
    while(step--){
        prev = prev->next;
    }

    ListNode* cur = prev->next;
    prev->next = nullptr;
    tmp->next = head;
    return cur;
}
```

时间复杂度： $O(N)$，两次遍历链表；

空间复杂度： $O(1)$

### Day 08

[24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

【思路——链表节点的next指针操作】

题目要求我们从头开始，两个一对交换链表中相邻的两个节点，记我们要交换的两个节点为 k1 和 k2；记k1前面一个节点为 prev，用题目中的例子即是`prev->k1->k2->3->4....`，要交换k1和k2需要三步操作：

```cpp
prev->next = k2;
k1->next = k2->next;
k2->next = k1;
```

交换后得到`prev->k2->k1->3->4....`，为交换后面的节点我们需要移动这三个指针，让prev指向k1，k1指向3，k2指向4，也是需要三步：

```cpp
prev = k1;
k1 = k1->next;
k2 = k1->next;
```

当然也要判断能不能向后走了，**交换完后**若要想后走就要保证后面的两个节点是存在的，即`k1->next && k1->next->next`为真。

为了方便处理边界条件，可以设一个虚拟头节点dummy，让dummy->next指向head；开始时让prev，k1和k2都指向dummy，发现执行一次上面的三步走法，刚好可以走成`prev->k1->k2->3->4...`；那我们只需要特判一下head是否为空就行了，其他情况都在while循环里了。

【C++代码】

```cpp
ListNode* swapPairs(ListNode* head) {
    if(!head)  return head;

    ListNode* dummy = new ListNode(-1);
    dummy->next = head;

    ListNode* prev = dummy;
    ListNode* k1 = dummy;
    ListNode* k2 = dummy;
    
    while(k1->next && k1->next->next){
        prev = k1;
        k1 = k1->next;
        k2 = k1->next;

        prev->next = k2;
        k1->next = k2->next;
        k2->next = k1;
    }

    return dummy->next;
}
```

时间复杂度： $O(N)$，遍历了一次链表；

空间复杂度： $O(1)$
