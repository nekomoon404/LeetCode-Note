### Day 13

[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

【思路1——层序遍历它求深度一直可以的🙂】

【C++代码】

```c++
int maxDepth(TreeNode* root) {
    if(!root)  return 0;
    int d = 0;
    queue<TreeNode*> que;
    que.push(root);

    while(!que.empty()) {
        int size = que.size();
        while(size--) {
            TreeNode* cur = que.front();
            que.pop();

            if(cur->left)  que.push(cur->left);
            if(cur->right)  que.push(cur->right);
        }
        d++;
    }

    return d;
}
```

时间复杂度： $O(n)$

空间复杂度： 最坏情况下$O(2^h-1)=O(n)$，其中$h$为二叉树的高度

【思路2——递归】

二叉树的深度等于 `max（左子树的深度，右子树的深度）+ 1` ，递归地计算子树的深度即可。

【C++代码】

```c++
int maxDepth(TreeNode* root) {
    if(!root)  return 0;
    return max(maxDepth(root->left), maxDepth(root->right)) + 1;
}
```

时间复杂度： $O(n)$

空间复杂度： $O(\log n)$

### Day 14

[100. 相同的树](https://leetcode-cn.com/problems/same-tree/)

【思路1——递归】

若两个树相同，则根节点相同，且左右子树分别相同。

```c++
bool isSameTree(TreeNode* p, TreeNode* q) {
    if(!p && !q)  return true;
    else if(!p && q || p && !q)  return false;
    else if(p->val != q->val)  return false;

    return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
}
```

时间复杂度： $O(n)$

空间复杂度： 考虑递归函数的开销就是$O(\log n)$

【思路2——迭代】

上面的递归写法是二叉树的前序遍历，自然可以写成迭代的形式；这里写成前序遍历或者层序遍历都可以。

```c++
bool isSameTree(TreeNode* p, TreeNode* q) {
    if(!p && !q)  return true;
    stack<TreeNode*> stk;
    stk.push(p);
    stk.push(q);

    while(!stk.empty()){
        TreeNode* qNode = stk.top();
        stk.pop();
        TreeNode* pNode = stk.top();
        stk.pop();

        if(!qNode && !pNode)  continue;
        if(!qNode || !pNode || pNode->val != qNode->val)  return false;

        stk.push(pNode->right);
        stk.push(qNode->right);
        stk.push(pNode->left);
        stk.push(qNode->left);
    }

    return true;
}
```

时间复杂度： $O(n)$

空间复杂度： $O(n)$

