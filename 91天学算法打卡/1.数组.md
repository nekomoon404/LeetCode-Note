### Day 01

[989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)

题目描述：

对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。

给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。

示例：

```
输入：A = [1,2,0,0], K = 34
输出：[1,2,3,4]
解释：1200 + 34 = 1234
```

【思路——数组模拟加法过程】

类似用数组模拟大数加法，即模拟人手算的过程，从低位开始，逐位相加，逢十进一，即：

 当前位 = (数A的当前位 + 数B的当前位 + 低位的进位carry) % 10。
 
 当最后的进位不为0时，需要添加到答案数组的起始位置，可以用 `vector` 的 `insert` 函数，如 `res.insert(res.begin(), carry)`；
 
 或者我们可以在存答案数组时，从低位到高位存，即`res[0]`表示最低位，这样在运算过程中一直向数组的尾部插入元素即可，最后再将数组翻转。


```c++
vector<int> addToArrayForm(vector<int>& num, int k) {
    int n = num.size();
    vector<int> res;

    int i = n - 1, sum = 0, carry = 0;
    while(i >= 0 || k != 0) {
        int a = i >= 0 ? num[i] : 0;
        int b = k != 0 ? k % 10 : 0;

        sum = a + b + carry;
        carry = sum / 10;
        res.push_back(sum % 10);

        i--;
        k /= 10;
    }

    if(carry != 0)
        res.push_back(carry);
    reverse(res.begin(), res.end());

    return res;
}
```

时间复杂度： $O(N)$，记 $N= \max(n, \log k)$，即表示答案数组的长度， `while` 遍历是 $O(N)$ 的复杂度，翻转数组也是 $o(N)$ 的复杂度。

空间复杂度： $O(N)$